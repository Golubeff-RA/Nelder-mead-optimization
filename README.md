# Nelder-mead-optimization
Приложение на ~~Qt~~ оптимизирующее функцию эвристикой Нелдера-Мида
~~Пишем только под винду, чтобы не парится с Cmake и подключением библиотеков в конфигах~~
А теперь выключаем клоунаду, потому что я сдался на этапе подключения gtest, а Владимир Владимирович видимо впринципе отрицает писание на плюсах без CMake (оно и правильно на самом деле). А ещё мы нашли библиотеку ImGUI которая весит 3Мб и позволяет писать UI на плюсах! Боже больше плюсов богу плюсов, в следующий раз будем сайт верстать с помощью cout. 

# Наброски архитектуры:
# Front: 
  - Вверху окошка строчка в которую можно напечатать функцию Q(X).
  - Кнопка проверки правильности введённой функции или форматирования строки согласно правилам записи функции.
  - Кнопка запуска оптимизатора, выдающая введенную строку std::string в оптимизатор.
  - Окошко для печати логов, которые будут выданы ядром в виде std::vector(Log) или std::list(Log) (вектор структур логов, в которых будут координаты опорных точек, значение Q(X), мера опорного симплекса)
  (площадь, объём, 4-х мерный объём и т. д.).
  - В самом низу выделенное строковое окно для финального ответа Q(X*) и сам X*.
# Ярдо: 
  - Оформлено в виде подключаемой .so, чтобы просто заинклюдить его в проек UI.
  - Содержит определение класса NelderMeadSolver.
  - Содержит определение Point
  - Содержит определение Function (вычисляет значение функции)
# NelderMeadSolver:
  # Поля класса: 
  - std::map(std::string, std::list(Log)) solution_logs // содержит ход решения для каждой оптимизированной функции
  - std::map(double, std::vector(Point)) landscape // содержит соответствие Q(X) и X последней оптимизируемой функции
  ....
  # Методы:
  - void Optimize(std::string function) // оптимизирует функцию заданную строкой (из Frontenda)
  - const std::list(Log)& GetLogs(std::string function) //выдаст логи решения по функции
  ....
# Как считать функцию?
Q(X) будет поступать в виде "x1*x2 + x3*x4 + x1 + x3". Сначала мы её разобьём на последовательность токенов, а потом вместо токенов x1, x2, x3 будет подставлять соотв. значения из Point в которой вычисляем Q(X). Значение выражения будем считать польской записью.

  
